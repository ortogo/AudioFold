use ["downloader", "files", "forms", "functional", "http", "java", "json", "std", "types"]

include "includes/constants.own"
include "includes/gui.own"
include "includes/config.own"
include "includes/telegram_api.own"

config = initConfig()

isWorked = false
isStopped = true
waitingGaugeIndex = 0

// Check config
if config.botToken == "" {
   logLabel.setText(logLabel.getText() + "<font color=\"red\">bot token is not set</font><br>")
}
if config.saveFolderPath == "" {
   logLabel.setText(logLabel.getText() + "<font color=\"red\">save folder path is not set</font><br>")
}
if !exists(config.saveFolderPath) {
   logLabel.setText(logLabel.getText() + "<font color=\"red\">save folder path [" + config.saveFolderPath + "] is not exists</font><br>")
}

bot = TelegramBot(config.botToken)

def downloadProgress(progress, bytesDownloaded, bytesMax) {
   bar = "#" * (progress / 2)
   progressStr = sprintf("%-50s %d%% %.2f / %.2f", bar, progress, bytesDownloaded / MBYTES, bytesMax/MBYTES)
   progressBarLabel.setText(progressStr)
}

def processAudio(audio) {
fileId = audio["file_id"]
   performer = audio["performer"]
   title = audio["title"]
   size = audio["file_size"]
   duration = audio["duration"]
   //thumb = audio["thumb"]["file_id"] // PhotoSize
   def storeAudio(fileJson) {
      filePath = fileJson["result"]["file_path"]
      println fileJson["result"]
      ext = substring(filePath, lastIndexOf(filePath, "."))
      name = performer + " - " + title + ext
// todo: filtr name
      path = config.saveFolderPath + name
      logStr = sprintf("Downloading %s<br>size: %.2f MiB, duration: %d", name, size/MBYTES, duration)
      pushLog(logStr)
      downloader(bot.createFileUrl(bot, filePath), path, ::downloadProgress)
      pushLog("Download done!")
      writeTags(path, performer, title, default(audio["thumb"], {}))
   }

   bot.getFile(bot, fileId, ::storeAudio)
   pushLog("Done!")
   progressBarLabel.setText("done")
   echo (audio)
}

def pushLog(text) {
   logLabel.setText(logLabel.getText() + text + "<br>")
}

def writeTags(path, artist, title, thumb = {}) {
   AudioFileIO = newClass("org.jaudiotagger.audio.AudioFileIO")
   FieldKey = newClass("org.jaudiotagger.tag.FieldKey")
   File = newClass("java.io.File")
   storedFile = File.new(path)

   af = AudioFileIO.read(storedFile)

   tag = af.getTag()
   // проверяем есть ли автор, если нет, то пишем теги
   if trim(string(tag.getFirst(FieldKey.ARTIST))) == "" {
      pushLog("Writing tags...")
      tag = af.createDefaultTag()
      tag.setField(FieldKey.ARTIST, [artist,])
      tag.setField(FieldKey.TITLE, [title,])
      
      // есть картинка
      if length(thumb) > 0 {
         pushLog("Writing artwork...")
         pushLog("Downloading image..")

         // колбек для загрузки изображения
         def storeImage(fileJson) {
            filePath = fileJson["result"]["file_path"]
            fileSize = thumb["file_size"]
            thumbWidth = thumb["width"]
            thumbHeight = thumb["height"]

            imagePath = "./image"
            logStr = sprintf("Downloading %s<br>size: %.2f MiB, size %dx%d", imagePath, fileSize/MBYTES, thumbWidth, thumbHeight)
            pushLog(logStr)
            downloader(bot.createFileUrl(bot, filePath), imagePath, ::downloadProgress)
            pushLog("Download done!")
         }

         // загрузка изображения
         bot.getFile(bot, thumb["file_id"], ::storeImage)
         
         imagePath = "./image"
         imageFile = File.new(imagePath)

         Artwork = newClass("org.jaudiotagger.tag.images.StandardArtwork")
         art = Artwork.new()
         art.setFromFile(imageFile)
         tag.setField(art)
         delete(imagePath)
      }
      af.setTag(tag)
   }
    
   AudioFileIO.write(af)
}

def updateWaitingGauge() {
   labels = ["*", "**", "***"]
   waitingLabel.setText(labels[waitingGaugeIndex % 3])
   waitingGaugeIndex++
}

def waitingUpdates() {
   isStopped = false
   pushLog("Started. Waiting for updates...")
   while isWorked {
      updates = bot.getUpdates(bot, config.lastUpdateId+1, def(update) {
         //println update
         results = update["result"]
         for result : results {
            updateId = int(result["update_id"])
            if config.lastUpdateId < updateId {
               config.lastUpdateId = updateId
            }
            println config.lastUpdateId
            pushLog("Update: " + config.lastUpdateId)

            if default(result["message"]["chat"], "") != "" {
               chatUsername = default(result["message"]["chat"]["username"], "")
               if trim(chatUsername) != trim(config.username) {
                  pushLog("Knok knok from " + chatUsername)
                  continue
               }
            }
            if default(result["message"]["audio"], "") != "" {
               //println result["message"]
               processAudio(result["message"]["audio"])
            } else {
               pushLog("No audio, text: " + default(result["message"]["text"], "null"))
            }
         }
      })
      updateWaitingGauge()
      sleep(500)
   }
   saveConfig(config)
   isStopped = true
   pushLog("Stopped waiting")
   //startButton.setText("Start")
}

