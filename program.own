use ["downloader", "files", "forms", "functional", "http", "java", "json", "std", "types"]

include "includes/constants.own"
include "includes/gui.own"
include "includes/config.own"
include "includes/telegram_api.own"
include "includes/audiotagger.own"

config = initConfig()

isWorked = false
isStopped = true

checkConfig()

bot = TelegramBot(config.botToken)

def downloadProgress(progress, bytesDownloaded, bytesMax) {
   bar = "#" * (progress / 2)
   progressStr = sprintf("%-50s %d%% %.2f / %.2f", bar, progress, bytesDownloaded / MBYTES, bytesMax/MBYTES)
   progressBarLabel.setText(progressStr)
}

def processAudio(audio) {
fileId = audio["file_id"]
   performer = audio["performer"]
   title = audio["title"]
   size = audio["file_size"]
   duration = audio["duration"]
   //thumb = audio["thumb"]["file_id"] // PhotoSize
   def storeAudio(fileJson) {
      filePath = fileJson["result"]["file_path"]
      println fileJson["result"]
      ext = substring(filePath, lastIndexOf(filePath, "."))
      name = performer + " - " + title + ext
// todo: filtr name
      path = config.saveFolderPath + name
      logStr = sprintf("Downloading %s<br>size: %.2f MiB, duration: %d", name, size/MBYTES, duration)
      pushLog(logStr)
      downloader(bot.createFileUrl(bot, filePath), path, ::downloadProgress)
      pushLog("Download done!")
      thumbPath = ""
      if default(audio["thumb"], "") != "" {
         pushLog("Downloading image..")
         // колбек для загрузки изображения
         def storeImage(fileJson) {
            filePath = fileJson["result"]["file_path"]
            fileSize = audio["thumb"]["file_size"]
            thumbWidth = audio["thumb"]["width"]
            thumbHeight = audio["thumb"]["height"]
            thumbPath = "./thumb"
            logStr = sprintf("Downloading %s<br>size: %.2f MiB, size %dx%d", thumbPath, fileSize/MBYTES, thumbWidth, thumbHeight)
            pushLog(logStr)
            downloader(bot.createFileUrl(bot, filePath), thumbPath, ::downloadProgress)
            pushLog("Download done!")
         }

         // загрузка изображения
         bot.getFile(bot, audio["thumb"]["file_id"], ::storeImage)
      }
      writeTags(path, performer, title, thumbPath)
   }

   bot.getFile(bot, fileId, ::storeAudio)
   pushLog("Done!")
   progressBarLabel.setText("done")
   echo (audio)
}

def waitingUpdates() {
   isStopped = false
   pushLog("Started. Waiting for updates...")
   while isWorked {
      updates = bot.getUpdates(bot, config.lastUpdateId+1, def(update) {
         //println update
         results = update["result"]
         for result : results {
            updateId = int(result["update_id"])
            if config.lastUpdateId < updateId {
               config.lastUpdateId = updateId
            }
            println config.lastUpdateId
            pushLog("Update: " + config.lastUpdateId)

            if default(result["message"]["chat"], "") != "" {
               chatUsername = default(result["message"]["chat"]["username"], "")
               if trim(chatUsername) != trim(config.username) {
                  pushLog("Knok knok from " + chatUsername)
                  continue
               }
            }
            if default(result["message"]["audio"], "") != "" {
               //println result["message"]
               processAudio(result["message"]["audio"])
            } else {
               pushLog("No audio, text: " + default(result["message"]["text"], "null"))
            }
         }
      })
      updateWaitingGauge()
      sleep(500)
   }
   saveConfig(config)
   isStopped = true
   pushLog("Stopped waiting")
   //startButton.setText("Start")
}

